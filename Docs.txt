++++++++++++++++++++++++++++++++++++++++++++++++++++++++
SynthBite16 - A 16 bit computer with micro-programmed control
Design, implementation and documentation by 'HarshaVardhan Rapeti'
++++++++++++++++++++++++++++++++++++++++++++++++++++++++



********************************************************
The design mainly focuses on : 

1 -> INSTRUCTION SET COMPLETENESS - A total of 39 instructions are currently present which pretty much cover up most of all the mandetory and some extra instructions which make programming in hasm extremely easy and comfortable.
2 -> FLEXIBILITY - Leftover microinstructions can be modified** by the user to create their custom instructions.
3 -> STACK!!! - we can perform operations on the stack(MAX_SIZE=8)
********************************************************
**the user need to modify the mapper circuit and write the ROM for the specific instruction.



INSTRUCTION FORMAT
------------------

General Instruction format:

    'XXXX XXXX XXXX XXXX'
     ^^^^ ^^^^ ^^^^ ^^^^
      1    2    3    4


1       ->  CONTAINS THE OP-CODE(12-14) AND THE MODE OF ADDRESSING(15). 
2, 3, 4 ->  CONTAINS THE OPERAND, ***CAN BE A ADDRESS OR DATA OR EXTENSION OF THE OP-CODE <-> WILL BE DISTINGUISHED FROM THE OP-CODE 

*the numbers in the bracketts represent the part of the respective data in the whole word.
**indexing starts from 0 from the LSB.

+++AS YOU CAN SEE THE WORD(16 bits) CAN BE DIVIDED INTO 4 '4-bit' 'BINARY REPRESENTED HEX VALUES' OR A NIBBLE.
+++SO ALL THE INSTRUCTIONS FROM NOW ON WILL BE REPRESENTED AS 4 HEX VALUES, WHICH IS EQUAL TO THE WHOLE WORD.
+++ANY X MEANS 'DO NOT CARE ABOUT THOSE VALUES WHILE DECODING THE INSTRUCTION'(IN THE, 'WHAT TO DO' PROCESS)



------------------------
REGISTERS AND THEIR USES
-------------------------------------------------------------------------------------------------------------
Name Size	FullForm		  Use
-------------------------------------------------------------------------------------------------------------
+++++
AC	16		ACCUMULATOR		        STORES THE CURRENT DATA WE ARE WORKING WITH.
PC	12		PROGRAM COUNTER		    STORES THE ADDRESS OF THE NEXT INSTRUCTION TO BE EXECUTED.
DR 	16		DATA REGISTER		      STORES THE LOADED OPERAND(VALUE AT ADDRESS WILL BE THE OPERAND).
IR	16		INSTRUCTION REGISTER	STORES THE CURRENT FULL INSTRUCTION WORD(TO BE DECODED AND EXECUTED).
AR	12		ADDRESS REGISTER	    STORES THE ADDRESS FROM 'PC'(TYPICALLY), CAN STORE ANY ADDRESS.
CR	3	  	COMPARISION REGISTER	STORES THE RESULTS FROM A 'CMP' INSTRUCTION.
TR	16		TEMPORARY REGISTER	  STORES TEMPORARY ADDRESSES OR DATA.(MOSTLY USED TO STORE THE DATA FROM ONE REGSTER TO ANOTHER DURING MICRO-OPERATIONS IN THE SAME MICRO-INSTRUCTION)
+++++
INPR	8		INPUT REGISTER		    STORES AN INPUT(CHAR) FROM AN EXTERNAL DEVICE.
OUTR	16	OUTPUT REGISTER		    STORES THE OUTPUT DATA.
+++++
SP	3		  STACK POINTER		      STORES THE 3-BIT ADDRESS OF THE PRESENT TOP OF THE INSTRUCTION STACK.
+++++
CAR	10		CONTROL ADDRESS REGISTER	THIS IS THE MAPPED VALUE OF THE INPUT DECODED INSTRUCTION, THE MICRO INSTRUCTIONS AT THIS POSITIONS WILL BE EXECUTED.
CDR	24		CONTROL DATA REGISTER	STORES THE CONTROL WORD, WILL FEEDBACK TO THE CONTROL SEQUENCER.
+++++
===============================================================================================================


--------------------------
STATUS BITS AND THEIR USES
---------------------------------------------------------------------------------------------------------------
Name	FullForm		Use
---------------------------------------------------------------------------------------------------------------
++++
E	OVERFLOW(TYPICALY)	CAN SEE THE OVERFLOW WHILE PERFORMING ARTHIMETIC ON AC USING ALU.(THIS STORES THE C_OUT FROM ADDERS, SUBTRACTORS ETC...)
++++
IEN	INTERRUPT ENABLE	WILL DECIDE IF INTERRUPT CAN OCCUR OR NOT(IF 0 INTERRUPT HAS TO WAIT FOR NEXT INSTRUCTION...)(IF CAN SET THE VALUE OF "R" TO 1).
R	INTERRUPT FLIP-FLOP	TELLS THE CPU TO SERVICE THE INTERRUPT.(WILL BE SET TO ZERO ONCE THE INTERRUPT IS DONE)
++++
FGI	INPUT FLAG		WILL TELL YOU IF YOU NEED TO DO AN INTERRUPT AND DO SOMETHING WITH THE INPUT.
++++
CSB	COMPARATOR STATUS BIT	A SINGLE BIT THAT DECIDES IF THE JUMP CONDITIONALLY IS GOING TO HAPPEN OR NOT.(SET BY INSTRUCTIONS LIKE "CSL", "CSG" ETC..)
++++
===============================================================================================================


VIRTUAL STATUS BITS AND THEIR USES
----------------------------------
--Not extra registers, part of an existing register, but convey something more than the rest of the bits.
----------------------------------------------------------------------------------------------------------------
Position	Use
----------------------------------------------------------------------------------------------------------------
IE(15)		DIRECT AND INDIRECT ADDRESSING BIT.
================================================================================================================


C.I.S.C - COMPLEX INSTRUCTION SET COMPUTER

HOW THE PROGRAM IS EXECUTED.
=============================================

1 -> FIRST, PROGRAMMER IS GOING TO WRITE THE PROGRAM IN THE FORM OF VALID INSTRUCTIONS.
2 -> COMPUTER STARTS EXECUTING INSTRUCTIONS STARTING FROM A PREDEFINED ADDRESS.
3 -> WHEN AN INSTRUCTION IS FED INTO THE CONTROL MAPPER.
	- THE 16 BIT INSTRUCTION IS MAPPED TO A 8 BIT ADDRESS IN THE CONTROL MEMORY.
	- THE CONRTOL SEQUENCER IS THE FIRST THING OUR 8 MAPPED BITS ARE GOING TO SEE, THE CONTROL SEQUENCER DECIDES WHAT TO DO AFTER THIS : 
		- IF THE FEEDBACK FROM THE CONTROL DATA REGISTER IS TELLING TO TAKE THE NEXT INSTRUCTION
			-THE PRESENT INSTRUCTION IS TAKEN IN AND THEN PUT INTO THE CONTROL REGISTER,
			-DIFFERENT MICROINSTRUCTIONS CAN TAKE DIFFERENT CLOCK CYCLES TO EXECUTE.
			-THE LAST 2 BITS OF THE MICROOPERATION TELLS THE SEQUENCER WHAT TO DO IN THE NEXT CLOCK CYCLE.
			-BASED ON THE END OF THE MICRO-INSTRUCTION, THE CONTROL SEQUENCER WILL DECIDE WHAT EXACTLY TO DO NEXT,
				-ANOTHER MICROINSTRUCTION ETC...
    - OR IT LOADES THE INSTRUCTION AT PC AS THE NEXT INSTRUCTION AND THIS PROCESS WILL BE REPEATED UNTIL THE EXECUTION HALTS.
4 -> THIS PROCESS IS CONTINUED FROM 1.

=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
INSTRUCTIONS
=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

-INSTRUCTIONS : (OPERAND IS THE VALUE WHICH IS AT THE ADDRESS IN THE INSTRUCTION())

	-OPERAND IS REQUIRED : 
		-DIRECT AND INDIRECT ADDRESSING
			=> 1 X X X | 9 X X X -> LFA -> LOAD       -> LOAD THE VALUE FROM THE ADDRESS INTO DR.                                       -> 03, 17
			=> 2 X X X | A X X X -> STR -> STORE      -> STORES THE PRESENT VALUE OF AC IN THE OPERAND ADDRESS.                         -> 05, 1A
			=> 3 X X X | B X X X -> JMP -> JUMP_COND  -> JUMP CONDITIONALLY TO THE GIVEN ADDRESS.                                       -> 07, 1D 
			=> 4 X X X | C X X X -> CAL -> CALL	      -> CALL A SUBROUTINE.                                                             -> 09, 21 ---
			=> 5 X X X | D X X X -> RET -> RETURN     -> RETURN FROM A SUBROUTINE.	                                                    -> 0c, 24 ---
			=> 6 X X X | E X X X -> LDI -> LOAD IMM   -> LOAD IMMEDIATE VALUE INTO THE AC, (THE HIGHEST 4 BITS WILL BE FILLED WITH 0).  -> 0f, 27 ---
			=> 7 X X X | F X X X -> SWP -> SWAP	      -> SWAPS THE VALUES OF AC AND THE OPERAND.                                        -> 12, 2a

(--- means the rom is not written for these instructions, because the assembling program cannot actually produce the machine code for these, 
     can be implemented by the user if intrested.)

	-OPERAND IS NOT REQUIRED : INSTRUCTION FORMAT 0-X-X-X OR 8-X-X-X

		-INSTRUCTIONS MANIPULATING DATA : 

			-INSTRUCTIONS ON THE STACK : 
				=> 8 0 X X -> PSH(70)  -> PUSH ONTO THE STACK		                -> (STACK TOP <- DR, SP <- SP + 1)
				=> 8 1 X X -> POP(73)  -> POP FROM THE STACK		                -> POP THE VALUE FROM THE STACK TOP AND PLACE IT IN THE OUT BUFFER REGISTER.
				=> 8 2 X X -> ADS(75)  -> ADD THE TOP TWO ELEMENTS IN THE STACK     -> (STACK TOP <- STACK TOP + STACK TOP AFTER A POP)
				=> 8 3 X X -> SDS(7c)  -> SUBTRACT ON THE STACK		                -> (STACK TOP <- STACK TOP - STACK TOP AFTER A POP)
				=> 8 4 X X -> MDS  -> MULTIPLY ON THE STACK		                -> (STACK TOP <- STACK TOP * STACK TOP AFTER A POP)
				=> 8 5 X X -> DDS  -> DIVIDE ON THE STACK		                -> (STACK TOP <- STACK TOP / STACK TOP AFTER A POP)
                => 8 6 X X -> LFS(84)  -> LOAD FROM STACK TOP                       -> (AC <- STACK TOP)

			-INSTRUCTIONS ON ACCUMULATOR AND DATA REGISTER : 
				=> 0 0 X X -> LFD(30)  -> LOAD FROM DR(AC <- DR) 		            -> LOAD THE VALUE OF THE DATA REGISTER INTO AC.
				=> 0 1 X X -> LDC(32)  -> LOAD DATA COMPLIMENT(AC <- ~DR)	        -> LOAD THE COMPLIMENT OF THE VALUE OF DR INTO AC.
				=> 0 2 X X -> ADD(34)  -> ADD(DR + AC) 			                    -> ADD THE VALUE OF DR AND AC AND STORE IT IN AC.
				=> 0 3 X X -> MUL(4A)  -> MULTIPLY(DR * AC) 		                -> MULTIPLY THE VALUE OF DR WITH AC.
				=> 0 4 X X -> SUB(36)  -> SUBTRACT(AC <- DR + (~AC + 1))	        -> SUBTRACT AC FROM DR.
				=> 0 5 X X -> DIV(9a)  -> DIVIDE(AC <- REMAINDER OF AC/DR, QR <- AC/DR) -> DIVIDE AC WITH DR.
				=> 0 6 X X -> CMP(46)  -> COMPARE THE VALUES OF DR AND AC           -> WILL SET THREE BITS BASED ON THE COMPARISION(SMALLER, EQUAL, GREATER).
				=> 0 7 X X -> AND(3c)  -> BITWISE AND(AC <- AC && DR)   	        -> BITWISE AND WITH AC.
				=> 0 8 X X -> BOR(38)  -> BITWISE OR(AC <- AC || DR)	            -> BITWISE OR WITH AC.
				=> 0 9 X X -> XOR(3a)  -> BITWISE XOR(AC <- AC ^ DR) 	            -> BITWISE XOR WITH AC.
				=> 0 A X X -> SHR(3e)  -> SHIFT AC TO RIGHT 		                -> SHIFT THE AC VALUE TO THE RIGHT.
				=> 0 B X X -> SHL(40)  -> SHIFT AC TO THE LEFT		                -> SHIFT THE AC VALUE TO THE LEFT.
			    => 0 D X X -> RND(42)  -> RANDOM NUMBER IN AC                       -> LOAD A RANDOM NUMBER IN AC.
                => 0 E X X -> IBO(44)  -> INCREMENT BY ONE                          -> AC <= AC+1

			-INSTRUCTIONS TO SET THE COMPARISION BITS : 
                => 8 7 X X -> CSC(87) ->  COMPARISION STATUS BIT -> COMPARE REGISTER CARRY(SETS THE COMPARE REGISTER THE PRESENT VALUE OF THE CARRY FLIP FLOP)
				=> 8 8 X X -> CSO(89) ->  COMPARISION STATUS BIT -> COMPARE REGISTER ONE(SETS THE COMPARE ONE WITHOUT CHECKING ANY OTHER STUFF)
				=> 8 9 X X -> CSL(8b) ->  COMPARISION STATUS BIT -> COMPARE REGISTER(LESSER)(COMPARE SET LESSER)
				=> 8 A X X -> CSE(8d) ->  COMPARISION STATUS BIT -> COMPARE REGISTER(EQUAL)
				=> 8 B X X -> CSG(8f) ->  COMPARISION STATUS BIT -> COMPARE REGISTER(GREATER)

			-EXTRA
				=> 0 C X X -> SSI(48) -> SET SERIAL INPUT TO 1		  -> SET THE SERIAL INPUTS FOR THE SHIFT OPERATIONS.(IT WILL BE 0 BY DEFAULT EVERY TIME)
				=> 0 F X X -> HLT(00) -> PROGRAM HALT 			      -> HALT THE EXECUTIION. 

		-INSTRUCTIONS RELATED I/O : 
			=> 8 C X X -> INP(91) -> LOAD THE VALUE FROM INPUT REGISTER INTO THE DATA REGISTER.
			=> 8 D X X -> OUT(94) -> PLACE THE VALUE OF AC IN THE OUPUT REGISTER. 
            => 8 E X X -> IEN(96) -> SET THE INTERRUPT ENABLE ON.
            => 8 F X X -> IEF(98) -> SET THE INTERRUPT ENABLE OF.


* CAN HAVE WAY MORE INSTRUCTIONS THAN THIS, BUT IT WILL OVERCOMPLICATE THE SYSTEM.
**here the terms microoperations, microinstructions and instructions are loosely used , please understand the referred term based on the context.
	


++++++++++++++++++++++
MAIN COMPUTER LOOP
++++++++++++++++++++++

BOOTSTRAP -> LOAD -> THE STARTING POINT OG THE PROGRAM IS GOING TO BE THE ADDRESS AT WHICH THE INSTRUCTIONS ARE GOING TO START(.instructions)
we are going to jump to the starting point of the instructions indirectly from the end of the bootstrap, which will put the computer in the user written instruction loop.
The instructions are going to be performed sequentially till they encounter "jmp", "cal" or "hlt" (or some other interrupt)
This is going to be repeated, thats it.

+++++++++++++++++++++++++++++
MEMORY LAYOUT OF THE RAM
+++++++++++++++++++++++++++++
===============================================================================
===============================================================================
--BOOTSTRAP--(0X000 -> 0X0FF)(FOLLOWING EMPTY SPACE WILL BE FILLED WITH ZEROS)
--INDIRECT JUMP ADDRESS-- -> (0X100) (STORES THE INSTRUCTION STARTING ENTRY POINT)
--DATA-- (0X101 -> 0XHHH) -> (VARIABLE SPACE DEPENDING ON THE PRESENT PROGRAM)
--SUBROUTINES-- -> (0XHHH -> 0XEEE) -> (
		- SUBROUTINE ARANGEMENT :
			--FIRST WORD IS LEFT EMPTY, TO STORE THE ADDRESS FROM WHERE IT JUMPED OR BEEN CALLED
			--THE LENGTH OF THE REMAINING WILL BE DEPENDING ON THE NUMBER OF INSTRUCTIONS IN THE SUBROUTINE
			--GENERALLY ENDS WITH A 'RET' OR A 'HLT'
	)
--INSTRUCTIONS-- ('NO' FREE WORD AT THE BEGINNING)
CONTINUOUSLY STORE THE INSTRUCTIONS TILL THEY END
-----
-----
-----0000-----'FILL THE REMAINING SPACE WITH ZEROS'
-----
-----
BEFORE THE END (0XIII -> 0XFFF) (STORE THE MAIN INTERRUPTS, LIKE PROGRAM KILL AND SO ON)
=================================================================================
=================================================================================



++++
ROM OUTPUTS AND THE SIGNIFICANCE OF EACH BIT(STORED IN CONTROL DATA REGISTER, SHOWN IN THE 'PRESENT CONTROL' LED'S IN THE LOGISIM CIRCUIT)

        XXXX|-XXXX|-XXXX|-X-X-XX|-XXX-X|-X-XX-X|XX-XX|-X-X-X-X| == 8 NIBBLES
         ^    ^     ^     ^ ^ ^   ^   ^  ^ ^  ^    ^   ^ ^ ^ ^
         1    2     3     4 5 6   7   8  9 A  B    C   D E F G

** this control is designed in such a way that, if all the outputs are zero, then there will not be any kind of change in the state of the circuit, only the CAR will increment by one.
 
1 => REGISTER OR MEMORY TO PUT ON THE BUS
2 => REGISTER OR MEMORY ADDRESS TO LOAD FROM THE BUS
3 => SELECT THE OUTPUT FROM THE ALU TO LOAD INTO AC
4 => ENABLE THE ALU MULTIPLEXER(USED WHEN THE MIROINSTRUCTION TAKES MORE THAN ONE-CLOCK CYCLE)
5 => SHIFT THE AC REGISTER TO THE LEFT
6 => FIRST BIT IS TO LOAD THE INPUT INTO mAC PARALLELY, AND THE SECOND BIT IS FOR LEFT SHIFTING mAC.
7 => SETTING THE CONDITION STATUS BIT, THIS WILL CONTROL IF THE NEXT "JMP" SHOULD OCCUR OR NOT, THIS IS BASICALLY AN OCTAL NUMBER,
  *GENERALLY THIS IS DONE AFTER A "CMP",IT IS LIKE A PART OF THE COMPARE OPERATION. 
      0, 6, 7 WILL SET THE NUMBERS TO VALUE TO ZERO.
      1 WILL SET IT TO ONE NO MATTER THE OTHER CONDITIONS(USE THIS WHEN YOU ARE JUMPING UNCONDITIONALLY AS WE DO NOT HAVE AN INSTRUCTION FOR IT).
      2 WILL SET THE VALUE TO CARRY FLIP-FLOP VALUE.
      3 WILL SET IT TO THE RESULT FROM THE LESSER FLIP-FLOP FROM THE COMPARISION RESULT.
      4 WILL SET IT TO EQUAL FLIP-FLOP FROM THE EQUALS TO FLIP-FLOP FROM THE COMPARISION RESULT.
      5 WILL SET TO THE GREATER THAN FLIP-FLOP FROM THE COMPARISION RESULT.
8 => RESET dAC && mAC
9 => LOAD Q PARALLELY
A => FIRST BIT : STACK POINTER COUNT GO UP OR DOWN(IF 1 CYCLES WILL MATTER), SECOND BIT : IF 1 COUNT WILL GO UP, ELSE COUNT WILL GO DOWN(FOR PUSH AND POP RESPECTIVELY)
B => ONLY ONE SHOULD BE '1' AT A TIME, 
        FIRST BIT : IR(0..=15) ON THE ADDRESS LINE
        SECOND BIT : AR ON THE ADDRESS LINE
        THIRD BIT : PC ON THE ADDRESS LINE

C => FIRST BIT : SHOULD CHANGE INTERRUPT ENABLE?
     SECOND BIT : IF SO, WHAT SHOULD IT BE SET TO.
D => PUT IR ON BUS.
E => CLEAR THE INTERRUPT BUFFER
F => CLEAR THE INPUT BUFFER
G => IF 1 THE NEXT MICRO-INSTRUCTION WILL BE THE FIRST INSTRUCTION OF THE NEXT INSTRUCTION IN THE SEQUENCE OF THE PROGRAM,
      IF 0 THE NEXT MICRO-INSTRUCTION IS FROM THE SAME INSTRUCTION, IT IS CONTINUING TO DO THE SAME INSTRUCTION.


THE STARTING MICRO-OPERATION OF EVERY INSTRUCTION WILL BE THE EXACT SAME THAT IS THE FETCH CYCLE:

* THE CONTROL FOR FETCHING OF THE INSTRUCTION IS NOT WRITTEN IN THE RAM, THE CIRCUIT WILL FETCH THE INSTRUCTION WHENEVER IT KNOWS THAT THE PREVIOUS INSTRUCTION IS COMPLETED.
  + THIS IS BECAUSE THE LAST BIT OF EACH CONTROL WORD IN THE ROM WILL TELL THE CIRCUIT TO LOAD THE NEXT INSTRUCTION OR THIS INSTRUCTION HAS SOME MICRO-INSTRUCTIONS LEFT.


&& SOME EXTRA DESIGN CHOICES AND THEIR REASONS :

@ ABOUT THE AND GATES AT CONTROLLED BUFFERS OR TRI-STATE BUFFERS, THIS IS BECAUSE OUR INSTRUCTION LOADING HAPPENS AFTER HALF A CYCLE AFTER COMPLETION OF THE PREVISOU INSTRUCTION,
  SO THIS MEANS THE OUTPUT FROM THESE REGISTERS WILL BE PUT ON THE BUS FO ONLY HALF OF THE CUCLE,
  THIS HELPS PREVENT CONFLICTS(TWO VALUES BEING PUT ON THE BUS AT THE SAME TIME).

@ ABOUT THE CONFUSING LOOKING INPUT FOR THE PC LOAD, WHEN WE ARE LOADING THE ADDRESS TO PC,
  + FOR "RET" AND "CALL" AFTER LOADING THE ADDRESS INTO THE ADDRESS REGISTER(FOR INDIRECT) WRITING THE PRESENT ADDRESS VALUE THE VALUE IN THE INSTRUCTION IN THE CASE OF THE 
    "CALL", NEXT WE ARE GOING TO GO TO THE 'ADDRESS + 1' VALUE BECAUSE THE SUBROUTINE INSTRUCTIONS WILL START FROM THE NEXT ADDRESS.
  + BUT IN THE CASE OF JUMP(AS OUR JUMP IS ALWAYS CONDITIONAL) IF THE CONDITION IS "1" THE ADDRESS TO WHICH + 1 IS LOADED, BUT IF IT NOT, THEN WE LOAD THE ADDRESS "PC + 1",
  EQUIVALENTLY SKIPPING THE JUMP INSTRUCTION.

